[#unordered_map]
== Class template unordered_map

:idprefix: unordered_map_

`boost::unordered_map` â€” An unordered associative container that associates unique keys with another value.

=== Synopsis

[source,c++,subs=+quotes]
-----
// #include <boost/unordered_map.hpp>

template<
  typename Key,
  typename Mapped,
  typename Hash = boost::hash<Key>,
  typename Pred = std::equal_to<Key>,
  typename Alloc = std::allocator<std::pair<Key const, Mapped>> >
class unordered_map {
public:
  // types
  typedef Key                                    key_type;
  typedef std::pair<Key const, Mapped>           value_type;
  typedef Mapped                                 mapped_type;
  typedef Hash                                   hasher;
  typedef Pred                                   key_equal;
  typedef Alloc                                  allocator_type;
  typedef typename allocator_type::pointer       pointer;
  typedef typename allocator_type::const_pointer const_pointer;
  typedef value_type&                            reference;
  typedef value_type const&                      const_reference;
  typedef _implementation-defined_                 size_type;
  typedef _implementation-defined_                 difference_type;
  typedef _implementation-defined_                 iterator;
  typedef _implementation-defined_                 const_iterator;
  typedef _implementation-defined_                 local_iterator;
  typedef _implementation-defined_                 const_local_iterator;
  typedef _implementation-defined_                 node_type;
  typedef _implementation-defined_                 insert_return_type;

  // construct/copy/destruct
  unordered_map();

  explicit unordered_map(size_type n,
                         hasher const& hf = hasher(),
                         key_equal const& eq = key_equal(),
                         allocator_type const& a  = allocator_type());

  unordered_map(unordered_map const& other);
  unordered_map(unordered_map&& other);

  explicit unordered_map(Allocator const& a);
  unordered_map(unordered_map const& other, Allocator const& a);
  unordered_map(unordered_map&& other, Allocator const& a);

  unordered_map(size_type n, allocator_type const& a);
  unordered_map(size_type n, hasher const& hf, allocator_type const& a);

  unordered_map(initializer_list<value_type> il,
                size_type n = _implementation-defined_,
                hasher const& hf = hasher(),
                key_equal const& eq = key_equal(),
                allocator_type const& a = allocator_type());

  template<typename InputIterator>
  unordered_map(InputIterator f,
                InputIterator l,
                size_type n = _implementation-defined_,
                hasher const& hf = hasher(),
                key_equal const& eq = key_equal(),
                allocator_type const& a  = allocator_type());

  template<typename InputIterator>
  unordered_map(InputIterator f,
                InputIterator l,
                size_type n,
                allocator_type const& a);

  template<typename InputIterator>
  unordered_map(InputIterator f,
                InputIterator l,
                size_type n,
                hasher const& hf,
                allocator_type const& a);

  ~unordered_map();

  unordered_map& operator=(unordered_map const& other);
  unordered_map& operator=(unordered_map&& other);
  unordered_map& operator=(initializer_list<value_type> il);

  // size and capacity
  bool empty() const;
  size_type size() const;
  size_type max_size() const;

  // iterators
  iterator begin();
  const_iterator begin() const;

  iterator end();
  const_iterator end() const;

  const_iterator cbegin() const;
  const_iterator cend() const;

  // modifiers
  template<typename... Args>
  std::pair<iterator, bool>
  emplace(Args&&... args);

  template<typename... Args>
  iterator
  emplace_hint(const_iterator hint, Args&&... args);

  std::pair<iterator, bool>
  insert(value_type const& obj);

  std::pair<iterator, bool>
  insert(value_type&& obj);

  insert_return_type insert(node_type&& nh);

  iterator insert(const_iterator hint, value_type const& obj);
  iterator insert(const_iterator hint, value_type&& obj);
  iterator insert(const_iterator hint, node_type&& nh);

  template<typename InputIterator>
  void insert(InputIterator first, InputIterator last);

  void insert(initializer_list<value_type> il);

  node_type extract(const_iterator position);
  node_type extract(key_type const& k);

  template<typename K>
  node_type extract(K&& k);

  iterator erase(const_iterator position);
  iterator erase(const_iterator first, const_iterator last);
  size_type erase(key_type const& k);

  template<typename K>
  size_type erase(K&& k);

  void quick_erase(const_iterator position);
  void erase_return_void(const_iterator position);

  void clear();
  void swap(unordered_map& other);

  template<typename H2, typename P2>
  void merge(unordered_map<Key, Mapped, H2, P2, Alloc>& source);

  template<typename H2, typename P2>
  void merge(unordered_map<Key, Mapped, H2, P2, Alloc>&& source);

  // observers
  allocator_type get_allocator() const;
  hasher hash_function() const;
  key_equal key_eq() const;

  // lookup
  iterator find(key_type const& k);
  const_iterator find(key_type const& k) const;

  template<typename K>
  iterator
  find(K const& k);

  template<typename K>
  const_iterator
  find(K const& k) const;

  template<
    typename CompatibleKey,
    typename CompatibleHash,
    typename CompatiblePredicate>
  iterator
  find(CompatibleKey const& k,
       CompatibleHash const& hash,
       CompatiblePredicate const&) eq;

  template<
    typename CompatibleKey,
    typename CompatibleHash,
    typename CompatiblePredicate>
  const_iterator
  find(CompatibleKey const& k,
       CompatibleHash const& hash,
       CompatiblePredicate const& eq) const;

  bool contains(key_type const& key) const;

  template<typename K>
  bool contains(K const& key);

  size_type count(key_type const& k) const;

  template<typename K>
  size_type count(K const& k) const;

  std::pair<iterator, iterator>
  equal_range(key_type const& k);

  std::pair<const_iterator, const_iterator>
  equal_range(key_type const& k) const;

  template<typename K>
  std::pair<iterator, iterator>
  equal_range(K const& k);

  template<typename K>
  std::pair<const_iterator, const_iterator>
  equal_range(K const& k) const;

  mapped_type& operator[](key_type const& k);

  Mapped& at(key_type const& k);
  Mapped const& at(key_type const& k) const;

  // bucket interface
  size_type bucket_count() const;
  size_type max_bucket_count() const;
  size_type bucket_size(size_type n) const;
  size_type bucket(key_type const& k) const;

  local_iterator begin(size_type n);
  const_local_iterator begin(size_type n) const;

  local_iterator end(size_type n);
  const_local_iterator end(size_type n) const;

  const_local_iterator cbegin(size_type n) const;
  const_local_iterator cend(size_type n) const;

  // hash policy
  float load_factor() const;
  float max_load_factor() const;

  void max_load_factor(float z);

  void rehash(size_type n);
  void reserve(size_type n);
};

// Equality Comparisons
template<
  typename Key,
  typename Mapped,
  typename Hash,
  typename Pred,
  typename Alloc>
bool operator==(unordered_map<Key, Mapped, Hash, Pred, Alloc> const& x,
                unordered_map<Key, Mapped, Hash, Pred, Alloc> const& y);

template<
  typename Key,
  typename Mapped,
  typename Hash,
  typename Pred,
  typename Alloc>
bool operator!=(unordered_map<Key, Mapped, Hash, Pred, Alloc> const& x,
                unordered_map<Key, Mapped, Hash, Pred, Alloc> const& y);

// swap
template<typename Key, typename Mapped, typename Hash, typename Pred,
         typename Alloc>
void swap(unordered_map<Key, Mapped, Hash, Pred, Alloc>& x,
          unordered_map<Key, Mapped, Hash, Pred, Alloc>& y);
-----

---

=== Description

*Template Parameters*

[cols="1,1"]
|===

|_Key_
|`Key` must be https://en.cppreference.com/w/cpp/named_req/Erasable[Erasable^] from the container (i.e. `allocator_traits` can destroy it).

|_Mapped_
|`Mapped` must be https://en.cppreference.com/w/cpp/named_req/Erasable[Erasable^] from the container (i.e. `allocator_traits` can destroy it).

|_Hash_
|A unary function object type that acts a hash function for a `Key`. It takes a single argument of type `Key` and returns a value of type `std::size_t`.

|_Pred_
|A binary function object that implements an equivalence relation on values of type `Key`. A binary function object that induces an equivalence relation on values of type `Key`. It takes two arguments of type `Key` and returns a value of type bool.

|_Alloc_
|An allocator whose value type is the same as the container's value type.

|===

The elements are organized into buckets. Keys with the same hash code are stored in the same bucket.

The number of buckets can be automatically increased by a call to insert, or as the result of calling rehash.

---

=== Typedefs

[source,c++,subs=+quotes]
----
typedef typename allocator_type::pointer pointer;
----

`value_type*` if `allocator_type::pointer` is not defined.

---

[source,c++,subs=+quotes]
----
typedef typename allocator_type::const_pointer const_pointer;
----

`boost::pointer_to_other<pointer, value_type>::type` if `allocator_type::const_pointer` is not defined.


---

[source,c++,subs=+quotes]
----
typedef _implementation-defined_ size_type;
----

An unsigned integral type.

`size_type` can represent any non-negative value of `difference_type`.

---

[source,c++,subs=+quotes]
----
typedef _implementation-defined_ difference_type;
----

A signed integral type.

Is identical to the difference type of `iterator` and `const_iterator`.

---

[source,c++,subs=+quotes]
----
typedef _implementation-defined_ iterator;
----

An iterator whose value type is `value_type`.

The iterator category is at least a forward iterator.

Convertible to `const_iterator`.

---

[source,c++,subs=+quotes]
----
typedef _implementation-defined_ const_iterator;
----

A constant iterator whose value type is `value_type`.

The iterator category is at least a forward iterator.

---

[source,c++,subs=+quotes]
----
typedef _implementation-defined_ local_iterator;
----

An iterator with the same value type, difference type and pointer and reference type as iterator.

A `local_iterator` object can be used to iterate through a single bucket.

---

[source,c++,subs=+quotes]
----
typedef _implementation-defined_ const_local_iterator;
----

A constant iterator with the same value type, difference type and pointer and reference type as const_iterator.

A const_local_iterator object can be used to iterate through a single bucket.

---

[source,c++,subs=+quotes]
----
typedef _implementation-defined_ node_type;
----

See node_handle_map for details.

---

[source,c++,subs=+quotes]
----
typedef _implementation-defined_ insert_return_type;
----

Structure returned by inserting node_type.

---

=== Constructors

==== Default Constructor
```c++
unordered_map();
```

Constructs an empty container using `hasher()` as the hash function,
`key_equal()` as the key equality predicate, `allocator_type()` as the allocator
and a maximum load factor of `1.0`.

Postconditions:: `size() == 0`
Requires:: If the defaults are used, `hasher`, `key_equal` and `allocator_type` need to be https://en.cppreference.com/w/cpp/named_req/DefaultConstructible[DefaultConstructible^].

---

==== Bucket Count Constructor
```c++
explicit unordered_map(size_type n,
                       hasher const& hf = hasher(),
                       key_equal const& eq = key_equal(),
                       allocator_type const& a = allocator_type());
```

Constructs an empty container with at least `n` buckets, using `hf` as the hash
function, `eq` as the key equality predicate, `a` as the allocator and a maximum
load factor of `1.0`.

Postconditions:: `size() == 0`

Requires:: If the defaults are used, `hasher`, `key_equal` and `allocator_type` need to be https://en.cppreference.com/w/cpp/named_req/DefaultConstructible[DefaultConstructible^].

---

==== Copy Constructor
```c++
unordered_map(unordered_map const& other);
```

The copy constructor. Copies the contained elements, hash function, predicate, maximum load factor and allocator.

If `Allocator::select_on_container_copy_construction` exists and has the right signature, the allocator will be constructed from its result.

Requires:: `value_type` is copy constructible

---

==== Move Constructor
```c++
unordered_map(unordered_map&& other);
```

The move constructor.

Notes:: This is implemented using Boost.Move.

Requires:: `value_type` is move-constructible. On compilers without rvalue reference support the emulation does not support moving without calling `boost::move` if `value_type` is not copyable.
So, for example, you can't return the container from a function.

---

==== Allocator Constructor
```c++
explicit unordered_map(Allocator const& a);
```

Constructs an empty container, using allocator `a`.

---

==== Copy Constructor with Allocator
```c++
unordered_map(unordered_map const& other, Allocator const& a);
```

Constructs an container, copying ``other``'s contained elements, hash function, predicate, maximum load factor, but using allocator `a`.

---

==== Move Constructor with Allocator
```c++
unordered_map(unordered_map&& other, Allocator const& a);
```

Construct a container moving ``other``'s contained elements, and having the hash function, predicate and maximum load factor, but using allocate `a`.

Notes:: This is implemented using Boost.Move.
Requires:: `value_type` is move insertable.

---

==== Bucket Count Constructor with Allocator
```c++
unordered_map(size_type n, allocator_type const& a);
```

Constructs an empty container with at least `n` buckets, using `hf` as the hash function, the default hash function and key equality predicate, `a` as the allocator and a maximum load factor of `1.0`.

Postconditions:: `size() == 0`
Requires:: `hasher` and `key_equal` need to be https://en.cppreference.com/w/cpp/named_req/DefaultConstructible[DefaultConstructible^].

---

==== Bucket Count Constructor with Hasher and Allocator
```c++
unordered_map(size_type n, hasher const& hf, allocator_type const& a);
```

Constructs an empty container with at least `n` buckets, using `hf` as the hash function, the default key equality predicate, `a` as the allocator and a maximum load factor of `1.0`.

Postconditions:: `size() == 0`
Requires:: `key_equal` needs to be https://en.cppreference.com/w/cpp/named_req/DefaultConstructible[DefaultConstructible^].

---

==== Initializer List Constructor
[source,c++,subs="quotes,macros"]
----
unordered_map(initializer_list++<++value_type++>++ il,
              size_type n = _implementation-defined_,
              hasher const& hf = hasher(),
              key_equal const& eq = key_equal(),
              allocator_type const& a = allocator_type());
----

Constructs an empty container with at least `n` buckets, using `hf` as the hash function, `eq` as the key equality predicate, `a` as the allocator and a maximum load factor of `1.0` and inserts the elements from `il` into it.

Requires:: If the defaults are used, `hasher`, `key_equal` and `allocator_type` need to be https://en.cppreference.com/w/cpp/named_req/DefaultConstructible[DefaultConstructible^].

---

==== Iterator Range Constructor
[source,c++,subs="quotes,macros"]
----
template++<++typename InputIterator++>++
unordered_map(InputIterator f,
              InputIterator l,
              size_type n = _implementation-defined_,
              hasher const& hf = hasher(),
              key_equal const& eq = key_equal(),
              allocator_type const& a = allocator_type());
----

Constructs an empty container with at least `n` buckets, using `hf` as the hash function, `eq` as the key equality predicate, `a` as the allocator and a maximum load factor of `1.0` and inserts the elements from `[f, l)` into it.

Requires:: If the defaults are used, `hasher`, `key_equal` and `allocator_type` need to be https://en.cppreference.com/w/cpp/named_req/DefaultConstructible[DefaultConstructible^].

---

==== Iterator Range Constructor with Bucket Count and Allocator
[source,c++,subs="quotes,macros"]
----
template++<++typename InputIterator++>++
unordered_map(InputIterator f,
              InputIterator l,
              size_type n,
              allocator_type const& a);
----

Constructs an empty container with at least `n` buckets, using `a` as the allocator, with the default hash function and key equality predicate and a maximum load factor of `1.0` and inserts the elements from `[f, l)` into it.

Requires:: `hasher`, `key_equal` need to be https://en.cppreference.com/w/cpp/named_req/DefaultConstructible[DefaultConstructible^].

==== Iterator Range Constructor with Bucket Count and Hasher
[source,c++,subs="quotes,macros"]
----
template++<++typename InputIterator++>++
unordered_map(InputIterator f,
              InputIterator l,
              size_type n,
              hasher const& hf,
              allocator_type const& a);
----

Constructs an empty container with at least `n` buckets, using `hf` as the hash function, `a` as the allocator, with the default key equality predicate and a maximum load factor of `1.0` and inserts the elements from `[f, l)` into it.

Requires:: `key_equal` needs to be https://en.cppreference.com/w/cpp/named_req/DefaultConstructible[DefaultConstructible^].

---

=== Destructor

```c++
~unordered_map();
```
Note:: The destructor is applied to every element, and all memory is deallocated

---

=== Assignment

==== Copy Assignment

```c++
unordered_map& operator=(unordered_map const& other);
```

The assignment operator. Copies the contained elements, hash function, predicate and maximum load factor but not the allocator.

If `Alloc::propagate_on_container_copy_assignment` exists and `Alloc::propagate_on_container_copy_assignment::value` is `true`, the allocator is overwritten, if not the copied elements are created using the existing allocator.

Requires:: `value_type` is copy constructible

---

==== Move Assignment
```c++
unordered_map& operator=(unordered_map&& other);
```
The move assignment operator.

If `Alloc::propagate_on_container_move_assignment` exists and `Alloc::propagate_on_container_move_assignment::value` is `true`, the allocator is overwritten, if not the moved elements are created using the existing allocator.

Notes:: On compilers without rvalue references, this is emulated using Boost.Move. Note that on some compilers the copy assignment operator may be used in some circumstances.

Requires:: `value_type` is move constructible.

---

==== Initializer List Assignment
```c++
unordered_map& operator=(initializer_list<value_type> il);
```

Assign from values in initializer list. All existing elements are either overwritten by the new elements or destroyed.

Requires:: `value_type` is https://en.cppreference.com/w/cpp/named_req/CopyInsertable[CopyInsertable^] into the container and https://en.cppreference.com/w/cpp/named_req/CopyAssignable[CopyAssignable^].

=== Size and Capacity

==== empty

```c++
bool empty() const;
```

Returns:: `size() == 0`

---

==== size

```c++
size_type size() const;
```

Returns:: `std::distance(begin(), end())`

---

==== max_size

```c++
size_type max_size() const;
```

Returns:: `size()` of the largest possible container.

---

=== Iterators

==== begin
```c++
iterator begin();
const_iterator begin() const;
```

Returns:: An iterator referring to the first element of the container, or if the container is empty the past-the-end value for the container.

---

==== end
```c++
iterator end();
const_iterator end() const;
```

Returns:: An iterator which refers to the past-the-end value for the container.

---

==== cbegin
```c++
const_iterator cbegin() const;
```
Returns:: A `const_iterator` referring to the first element of the container, or if the container is empty the past-the-end value for the container.

---

==== cend
```c++
const_iterator cend() const;
```

Returns:: A `const_iterator` which refers to the past-the-end value for the container.

---

=== Modifiers

==== emplace
```c++
template<typename... Args>
std::pair<iterator, bool>
emplace(Args&&... args);
```

Inserts an object, constructed with the arguments `args`, in the container if and only if there is no element in the container with an equivalent key.

Requires:: `value_type` is https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible[EmplaceConstructible^] into `X` from `args`.

Returns:: The bool component of the return type is true if an insert took place. +
If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.

Throws:: If an exception is thrown by an operation other than a call to `hasher` the function has no effect.

Notes:: Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.
Pointers and references to elements are never invalidated.
If the compiler doesn't support variadic template arguments or rvalue references, this is emulated for up to `10` arguments, with no support for rvalue references or move semantics.
Since existing `std::pair` implementations don't support `std::piecewise_construct` this emulates it, but using `boost::unordered::piecewise_construct`.

---

==== emplace_hint
```c++
template<typename... Args>
iterator
emplace_hint(const_iterator hint, Args&&... args);
```

Inserts an object, constructed with the arguments `args`, in the container if and only if there is no element in the container with an equivalent key.

`hint` is a suggestion to where the element should be inserted.

Requires:: `value_type` is https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible[EmplaceConstructible^] into `X` from `args`.

Returns:: If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.

Throws:: If an exception is thrown by an operation other than a call to `hasher` the function has no effect.

Notes:: The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.
Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.
Pointers and references to elements are never invalidated.
If the compiler doesn't support variadic template arguments or rvalue references, this is emulated for up to 10 arguments, with no support for rvalue references or move semantics.
Since existing `std::pair` implementations don't support `std::piecewise_construct` this emulates it, but using `boost::unordered::piecewise_construct`.

---

==== Copy Insert
```c++
std::pair<iterator, bool>
insert(value_type const& obj);
```

Inserts `obj` in the container if and only if there is no element in the container with an equivalent key.

Requires:: `value_type` is https://en.cppreference.com/w/cpp/named_req/CopyInsertable[CopyInsertable^].

Returns:: The bool component of the return type is true if an insert took place. If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.

Throws:: If an exception is thrown by an operation other than a call to `hasher` the function has no effect.

Notes:: Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor. Pointers and references to elements are never invalidated.

---

==== Move Insert
```c++
std::pair<iterator, bool>
insert(value_type&& obj);
```

Inserts `obj` in the container if and only if there is no element in the container with an equivalent key.

Requires:: `value_type` is https://en.cppreference.com/w/cpp/named_req/MoveInsertable[MoveInsertable^].

Returns:: The bool component of the return type is true if an insert took place. If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.

Throws:: If an exception is thrown by an operation other than a call to `hasher` the function has no effect.

Notes:: Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor. Pointers and references to elements are never invalidated.

---

==== Insert with `node_handle`
```c++
insert_return_type
insert(node_type&& nh);
```

If `nh` is empty, has no effect.

Otherwise inserts the element owned by `nh` if and only if there is no element in the container with an equivalent key.

Requires:: `nh` is empty or `nh.get_allocator()` is equal to the container's allocator.

Returns:: If `nh` was empty, returns an `insert_return_type` with: `inserted` equal to `false`, `position` equal to `end()` and `node` empty. Otherwise if there was already an element with an equivalent key, returns an `insert_return_type` with: `inserted` equal to `false`, `position` pointing to a matching element and `node` contains the node from `nh`. Otherwise if the insertion succeeded, returns an `insert_return_type` with: `inserted` equal to `true`, `position` pointing to the newly inserted element and `node` empty.

Throws:: If an exception is thrown by an operation other than a call to `hasher` the function has no effect.

Notes:: Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor. Pointers and references to elements are never invalidated. In C++17 this can be used to insert a node extracted from a compatible `unordered_multimap`, but that is not supported yet.

---

==== Copy Insert with Hint
```c++
iterator insert(const_iterator hint, value_type const& obj);
```
Inserts `obj` in the container if and only if there is no element in the container with an equivalent key.

`hint` is a suggestion to where the element should be inserted.

Requires:: `value_type` is https://en.cppreference.com/w/cpp/named_req/CopyInsertable[CopyInsertable^].

Returns:: If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.

Throws:: If an exception is thrown by an operation other than a call to `hasher` the function has no effect.

Notes:: The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key. Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor. Pointers and references to elements are never invalidated.

---

==== Move Insert with Hint
```c++
iterator insert(const_iterator hint, value_type&& obj);
```

Inserts `obj` in the container if and only if there is no element in the container with an equivalent key.

`hint` is a suggestion to where the element should be inserted.

Requires:: `value_type` is https://en.cppreference.com/w/cpp/named_req/MoveInsertable[MoveInsertable^].

Returns:: If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.

Throws:: If an exception is thrown by an operation other than a call to `hasher` the function has no effect.

Notes:: The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key. Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor. Pointers and references to elements are never invalidated.

---

==== Insert with Hint and `node_handle`
```c++
iterator insert(const_iterator hint, node_type&& nh);
```

If `nh` is empty, has no effect.

Otherwise inserts the element owned by `nh` if and only if there is no element in the container with an equivalent key.

If there is already an element in the container with an equivalent key has no effect on `nh` (i.e. `nh` still contains the node.)

`hint` is a suggestion to where the element should be inserted.

Requires:: `nh` is empty or `nh.get_allocator()` is equal to the container's allocator.

Returns:: If `nh` was empty returns `end()`. If there was already an element in the container with an equivalent key returns an iterator pointing to that. Otherwise returns an iterator pointing to the newly inserted element.

Throws:: If an exception is thrown by an operation other than a call to hasher the function has no effect.

Notes:: The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key. Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor. Pointers and references to elements are never invalidated. In C++17 this can be used to insert a node extracted from a compatible `unordered_multimap`, but that is not supported yet.

---

==== Insert Iterator Range
```c++
template<typename InputIterator>
void insert(InputIterator first, InputIterator last);
```

Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent key.

Requires:: `value_type` is https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible[EmplaceConstructible^] into `X` from `*first`.

Throws:: When inserting a single element, if an exception is thrown by an operation other than a call to `hasher` the function has no effect.

Notes:: Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor. Pointers and references to elements are never invalidated.

---

==== Insert Initializer List
```c++
void insert(initializer_list<value_type> il);
```

Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent key.

Requires:: `value_type` is https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible[EmplaceConstructible^] into `X` from `*first`.

Throws:: When inserting a single element, if an exception is thrown by an operation other than a call to `hasher` the function has no effect.

Notes:: Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor. Pointers and references to elements are never invalidated.

---

==== Extract by Iterator
```c++
node_type extract(const_iterator position);
```

Removes the element pointed to by `position`.

Returns:: A `node_type` owning the element.

Notes:: In C++17 a node extracted using this method can be inserted into a compatible `unordered_multimap`, but that is not supported yet.

---

==== Transparent Extract by Key
```c++
template<typename K>
node_type extract(K&& k);
```

Removes an element with key equivalent to `k`.

This overload only participates in overload resolution if `Hash::is_transparent` and `Pred::is_transparent` are valid member typedefs and neither `iterator` nor `const_iterator` are implicitly convertible from `K`. The library assumes that `Hash` is callable with both `K` and `Key` and that `Pred` is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the `Key` type.

Returns:: A `node_type` owning the element if found, otherwise an empty `node_type`.

Throws:: Only throws an exception if it is thrown by `hasher` or `key_equal`.

Notes:: In C++17 a node extracted using this method can be inserted into a compatible `unordered_multimap`, but that is not supported yet.

---

==== Extract by Key
```c++
node_type extract(key_type const& k);
```

Removes an element with key equivalent to `k`.

Returns:: A `node_type` owning the element if found, otherwise an empty `node_type`.

Throws:: Only throws an exception if it is thrown by `hasher` or `key_equal`.

Notes:: In C++17 a node extracted using this method can be inserted into a compatible `unordered_multimap`, but that is not supported yet.

==== Erase by Position

```c++
iterator erase(const_iterator position);
```

Erase the element pointed to by `position`.

Returns:: The iterator following `position` before the erasure.

Throws:: Only throws an exception if it is thrown by `hasher` or `key_equal`.

Notes:: In older versions this could be inefficient because it had to search through several buckets to find the position of the returned iterator. The data structure has been changed so that this is no longer the case, and the alternative erase methods have been deprecated.

---

==== Erase Range

```c++
iterator erase(const_iterator first, const_iterator last);
```

Erases the elements in the range from `first` to `last`.

Returns:: The iterator following the erased elements - i.e. `last`.

Throws:: Only throws an exception if it is thrown by `hasher` or `key_equal`. In this implementation, this overload doesn't call either function object's methods so it is no throw, but this might not be true in other implementations.

---

==== Transparent Erase by Key
```c++
template<typename K>
size_type erase(K&& k);
```

Erase all elements with key equivalent to `k`.

This overload only participates in overload resolution if `Hash::is_transparent` and `Pred::is_transparent` are valid member typedefs and neither `iterator` nor `const_iterator` are implicitly convertible from `K`. The library assumes that `Hash` is callable with both `K` and `Key` and that `Pred` is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the `Key` type.

Returns:: The number of elements erased.

Throws:: Only throws an exception if it is thrown by `hasher` or `key_equal`.

---

==== Erase by Key
```c++
size_type erase(key_type const& k);
```

Erase all elements with key equivalent to `k`.

Returns:: The number of elements erased.

Throws:: Only throws an exception if it is thrown by `hasher` or `key_equal`.

---

==== quick_erase
```c++
void quick_erase(const_iterator position);
```

Erase the element pointed to by `position`.

Throws:: Only throws an exception if it is thrown by `hasher` or `key_equal`. In this implementation, this overload doesn't call either function object's methods so it is no throw, but this might not be true in other implementations.

Notes:: This method was implemented because returning an iterator to the next element from erase was expensive, but the container has been redesigned so that is no longer the case. So this method is now deprecated.

---

==== erase_return_void
```c++
void erase_return_void(const_iterator position);
```

Erase the element pointed to by `position`.

Throws:: Only throws an exception if it is thrown by `hasher` or `key_equal`. In this implementation, this overload doesn't call either function object's methods so it is no throw, but this might not be true in other implementations.

Notes:: This method was implemented because returning an iterator to the next element from erase was expensive, but the container has been redesigned so that is no longer the case. So this method is now deprecated.

---

==== clear
```c++
void clear();
```

Erases all elements in the container.

Postconditions:: `size() == 0`

Throws:: Never throws an exception.

---

==== swap
```c++
void swap(unordered_map& other);
```

Swaps the contents of the container with the parameter.

If `Allocator::propagate_on_container_swap` is declared and `Allocator::propagate_on_container_swap::value` is `true` then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.

Throws:: Doesn't throw an exception unless it is thrown by the copy constructor or copy assignment operator of `key_equal` or `hasher`.

Notes:: The exception specifications aren't quite the same as the C++11 standard, as the equality predicate and hash function are swapped using their copy constructors.

---

==== merge
```c++
template<typename H2, typename P2>
void merge(unordered_map<Key, Mapped, H2, P2, Alloc>& source);
```

Notes:: Does not support merging with a compatible `unordered_multimap` yet.

---

==== merge (rvalue reference)
```c++
template<typename H2, typename P2>
void merge(unordered_map<Key, Mapped, H2, P2, Alloc>&& source);
```

Notes:: Does not support merging with a compatible `unordered_multimap` yet.

---

=== Observers

==== get_allocator
```
allocator_type get_allocator() const;
```

==== hash_function
```
hasher hash_function() const;
```

Returns:: The container's hash function.

---

```
key_equal key_eq() const;
```

Returns:: The container's key equality predicate

---

=== Lookup

==== find
```c++
iterator find(key_type const& k);
const_iterator find(key_type const& k) const;

template<typename K>
iterator
find(K const& k);

template<typename K>
const_iterator
find(K const& k) const;

template<
  typename CompatibleKey,
  typename CompatibleHash,
  typename CompatiblePredicate>
iterator
find(CompatibleKey const& k,
     CompatibleHash const& hash,
     CompatiblePredicate const& eq);

template<
  typename CompatibleKey,
  typename CompatibleHash,
  typename CompatiblePredicate>
const_iterator
find(CompatibleKey const& k,
      CompatibleHash const& hash,
      CompatiblePredicate const& eq) const;

```

Returns:: An iterator pointing to an element with key equivalent to `k`, or `b.end()` if no such element exists.

Notes:: The templated overloads containing `CompatibleKey`, `CompatibleHash` and `CompatiblePredicate` are non-standard extensions which allow you to use a compatible hash function and equality predicate for a key of a different type in order to avoid an expensive type cast. In general, its use is not encouraged and instead the `K` member function templates should be used. +
The `template <typename K>` overloads only participate in overload resolution if `Hash::is_transparent` and `Pred::is_transparent` are valid member typedefs. The library assumes that `Hash` is callable with both `K` and `Key` and that `Pred` is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the `Key` type.

---

==== contains
```c++
template<typename K>
bool contains(K const& key);
bool contains(key_type const& key) const;
```

Returns:: A boolean indicating whether or not there is an element with key equal to `key` in the container

Notes:: The `template <typename K>` overload only participates in overload resolution if `Hash::is_transparent` and `Pred::is_transparent` are valid member typedefs. The library assumes that `Hash` is callable with both `K` and `Key` and that `Pred` is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the `Key` type.

---

==== count
```c++
template<typename K>
size_type count(K const& k) const;
size_type count(key_type const& k) const;
```

Returns:: The number of elements with key equivalent to `k`.

Notes:: The `template <typename K>` overload only participates in overload resolution if `Hash::is_transparent` and `Pred::is_transparent` are valid member typedefs. The library assumes that `Hash` is callable with both `K` and `Key` and that `Pred` is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the `Key` type.

---

==== equal_range
```c++
std::pair<iterator, iterator>
equal_range(key_type const& k);

std::pair<const_iterator, const_iterator>
equal_range(key_type const& k) const;

template<typename K>
std::pair<iterator, iterator>
equal_range(K const& k);

template<typename K>
std::pair<const_iterator, const_iterator>
equal_range(K const& k) const;
```

Returns:: A range containing all elements with key equivalent to `k`. If the container doesn't contain any such elements, returns `std::make_pair(b.end(), b.end())`.

Notes:: The `template <typename K>` overloads only participate in overload resolution if `Hash::is_transparent` and `Pred::is_transparent` are valid member typedefs. The library assumes that `Hash` is callable with both `K` and `Key` and that `Pred` is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the `Key` type.

---

==== operator++[++++]++
```c++
mapped_type& operator[](key_type const& k);
```

Effects:: If the container does not already contain an elements with a key equivalent to `k`, inserts the value `std::pair<key_type const, mapped_type>(k, mapped_type())`.

Returns:: A reference to `x.second` where `x` is the element already in the container, or the newly inserted element with a key equivalent to `k`.

Throws:: If an exception is thrown by an operation other than a call to `hasher` the function has no effect.

Notes:: Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor. Pointers and references to elements are never invalidated.

---

==== at
```c++
Mapped& at(key_type const& k);
Mapped const& at(key_type const& k) const;
```

Returns:: A reference to `x.second` where `x` is the (unique) element whose key is equivalent to `k`.

Throws:: An exception object of type `std::out_of_range` if no such element is present.

---

=== Bucket Interface

==== bucket_count
```c++
size_type bucket_count() const;
```

Returns:: The number of buckets.

---

==== max_bucket_count
```c++
size_type max_bucket_count() const;
```

Returns:: An upper bound on the number of buckets.

---

==== bucket_size
```c++
size_type bucket_size(size_type n) const;
```

Requires:: `n < bucket_count()`

Returns:: The number of elements in bucket `n`.

---

==== bucket
```c++
size_type bucket(key_type const& k) const;
```

Returns:: The index of the bucket which would contain an element with key `k`.

Postconditions:: The return value is less than `bucket_count()`.

---

==== begin

```c++
local_iterator begin(size_type n);
const_local_iterator begin(size_type n) const;
```

Requires:: `n` shall be in the range `[0, bucket_count())`.

Returns:: A local iterator pointing the first element in the bucket with index `n`.

---

==== end
```c++
local_iterator end(size_type n);
const_local_iterator end(size_type n) const;
```

Requires:: `n` shall be in the range `[0, bucket_count())`.

Returns:: A local iterator pointing the 'one past the end' element in the bucket with index `n`.

---

==== cbegin
```c++
const_local_iterator cbegin(size_type n) const;
```

Requires:: `n` shall be in the range `[0, bucket_count())`.

Returns:: A constant local iterator pointing the first element in the bucket with index `n`.

---

==== cend
```c++
const_local_iterator cend(size_type n) const;
```

Requires:: `n` shall be in the range `[0, bucket_count())`.

Returns:: A constant local iterator pointing the 'one past the end' element in the bucket with index `n`.

---

=== Hash Policy

==== load_factor
```c++
float load_factor() const;
```

Returns:: The average number of elements per bucket.

---

==== max_load_factor

```c++
float max_load_factor() const;
```

Returns:: Returns the current maximum load factor.

---

==== Set max_load_factor
```c++
void max_load_factor(float z);
```

Effects:: Changes the container's maximum load factor, using `z` as a hint.

---


==== rehash
```c++
void rehash(size_type n);
```

Changes the number of buckets so that there at least `n` buckets, and so that the load factor is less than the maximum load factor.

Invalidates iterators, and changes the order of elements. Pointers and references to elements are not invalidated.

Throws:: The function has no effect if an exception is thrown, unless it is thrown by the container's hash function or comparison function.

---

==== reserve
```c++
void reserve(size_type n);
```

Invalidates iterators, and changes the order of elements. Pointers and references to elements are not invalidated.

Throws:: The function has no effect if an exception is thrown, unless it is thrown by the container's hash function or comparison function.

=== Equality Comparisons

==== operator==
```c++
template<
  typename Key,
  typename Mapped,
  typename Hash,
  typename Pred,
  typename Alloc>
bool operator==(unordered_map<Key, Mapped, Hash, Pred, Alloc> const& x,
                unordered_map<Key, Mapped, Hash, Pred, Alloc> const& y);
```

Return `true` if `x.size() == y.size()` and for every element in `x`, there is an element in `y` with the same key, with an equal value (using `operator==` to compare the value types).

Notes:: The behavior of this function was changed to match the C++11 standard in Boost 1.48. Behavior is undefined if the two containers don't have equivalent equality predicates.

---

==== operator!=
```c++
template<
  typename Key,
  typename Mapped,
  typename Hash,
  typename Pred,
  typename Alloc>
bool operator!=(unordered_map<Key, Mapped, Hash, Pred, Alloc> const& x,
                unordered_map<Key, Mapped, Hash, Pred, Alloc> const& y);
```

Return `false` if `x.size() == y.size()` and for every element in `x`, there is an element in `y` with the same key, with an equal value (using `operator==` to compare the value types).

Notes:: The behavior of this function was changed to match the C++11 standard in Boost 1.48. Behavior is undefined if the two containers don't have equivalent equality predicates.

=== Swap
```c++
template<typename Key, typename Mapped, typename Hash, typename Pred,
         typename Alloc>
void swap(unordered_map<Key, Mapped, Hash, Pred, Alloc>& x,
          unordered_map<Key, Mapped, Hash, Pred, Alloc>& y);
```

Swaps the contents of `x` and `y`.

If `Allocator::propagate_on_container_swap` is declared and `Allocator::propagate_on_container_swap::value` is `true` then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.

Effects:: `x.swap(y)`

Throws:: Doesn't throw an exception unless it is thrown by the copy constructor or copy assignment operator of `key_equal` or `hasher`.

Notes:: The exception specifications aren't quite the same as the C++11 standard, as the equality predicate and hash function are swapped using their copy constructors.


